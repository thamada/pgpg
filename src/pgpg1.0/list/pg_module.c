/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* nbit   :   24-bit      */
/* ADDSUB :   SUB          */
#include<stdio.h>
void pg_fix_sub_24(int x,int y,int* z){
  unsigned int _x;
  unsigned int _y;
  int _z;
  _x = 0xFFFFFF&x;
  _y = 0xFFFFFF&y;
  _z = (int)(_x - _y);
  *z = 0xFFFFFF&_z;
}
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* nbit_fix   :   24-bit      */          
/* nbit_log   :   14-bit      */          
/* nbit_man   :   5-bit      */          
#include<stdio.h>                                                  
#include<math.h>                                                   
void pg_conv_ftol_fix24_log14_man5(int fixdata, int* logdata){                 
  int fixdata_msb=0;                                               
  int logdata_sign=0;                                              
  int fixdata_body=0;                                              
  int abs=0;                                                       
  int abs_decimal=0;                                               
  int logdata_nonzero=0;                                           
  int penc_out = 0; /* Output of penc */                           
  int table_adr = 0;                                               
  int table_overflow = 0;                                          
  int logdata_mantissa=0;                                          
  int logdata_exponent=0;                                          

  /* SIGN BIT */                                                   
  fixdata_msb = 0x1&(fixdata >>23);         
  logdata_sign = fixdata_msb;                                      

  /* ABSOLUTE */                                                   
  fixdata_body    = 0x7FFFFF & fixdata;        
  {                                                                
    int inv_fixdata_body=0;                                        
    inv_fixdata_body = 0x7FFFFF ^ fixdata_body;
    if(fixdata_msb == 0x1){                                        
      abs = 0x7FFFFF & (inv_fixdata_body + 1); 
    }else{                                                         
      abs = fixdata_body;                                          
    }                                                              
  }                                                                
  abs_decimal = 0x3FFFFF& abs;                 

  /* GENELATE NON-ZERO BIT (ALL BIT OR) */                                 
  if(abs != 0x0){ logdata_nonzero = 0x1; }else{ logdata_nonzero=0x0; }     

  { /* PRIORITY ENCODER */                                         
    int i;                                                         
    int count=0;                                                   
    for(i=31;i >=0;i--){                                           
        int buf;                                                   
        buf = 0x1 & (abs >>i);                                     
        if(buf == 0x1){ count = i; break;}                         
        count = i;                                                 
    }                                                              
    penc_out=count;                                                
  }                                                                
  penc_out = 0x1F & penc_out; /* 5-bit */
  
  /* SHIFTER */                                                                      
  {                                                                                  
    int seed=0;                                                                      
    if(penc_out>=7){                                         
      seed = abs_decimal;                                                            
      table_adr = 0x7F & (seed>>(penc_out-7));
    }else{                                                                           
      seed = abs_decimal << 7;                               
      table_adr = 0x7F & (seed>>penc_out);                         
    }                                                                                
  }                                                                                  
  
  /* TABLE */                                                                        
  /* TABLE INPUT WIDTH  = 7-bit */                           
  /* TABLE OUTPUT WIDTH = 5-bit */                             
  {                                                                                  
    int adr=0;                                                                       
    double adr_double=0.0;                                                           
    double data_double=0.0;                                                          
    int data;                                                                        
    adr = 0x7F & table_adr;                                  
    adr_double =   ( ((double)adr) + 0.5 )/128.000000;   
    data_double = 32.000000*(log(1.0 + adr_double))/log(2.0) + 0.5;
    data = (int)data_double;                                                         
    /* CHECK OVERFLOW */                                                             
    if((0x1&(data >>5))==0x1){                                   
      data = 0;                                                                      
      table_overflow = 1;   /* overflow flag */                                      
    }else{                                                                           
      table_overflow = 0;                                                            
    }                                                                                
    logdata_mantissa = 0x1F & data;                            
  }                                                                                  
  
  /* ADDER (GENERATE EXPONENT PART) */                                               
  logdata_exponent = 0x1F & (penc_out + table_overflow);  
  
  *logdata = logdata_sign << 13| logdata_nonzero << 12| logdata_exponent << 5| logdata_mantissa ;
  
  return;                                                          
}                                                                  
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* PIPELINE DELAY */
/* nbit   :   14-bit    */
/* npipe  :   14-stage  */
 
#include<stdio.h>                                
void pg_pdelay_14_np14(int indata, int* outdata){
  *outdata = 0x3FFF&indata;      
  return;                                        
}          
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* UNSIGNED logarithmic shifter(power 2^[nshift]) */
/* nbit   :   14-bit      */ 
/* nshift :   1-bit      */         
/* --- [NOTE!] ---
   Input/Output width of this component is different !
     Input Width : 14-bit. [14-bit Signed Logarithmic Format] 
     Onput Width : 13-bit. [14-bit Unsigned Logarithmic Format without a sign bit.] */

/* --- [NOTE!] ---
   nshift must be 2, 1, -1 or -2. */

#include<stdio.h>                                        
void pg_log_shift_log14_1(int logimage_x, int* logimage_z){ 
  int x_sign=0;        /* Sign Flag:  1-bit (for debug)*/
  int x_nonzero=0;     /* NonZero Flag: 1-bit */         
  int x_body=0;        /* 12-bit */   
  int z=0;             /* 13-bit */   

  x_sign    = 0x1&(logimage_x>>13);  /* for debug */
  x_nonzero = 0x1&(logimage_x>>12);
  x_body    = 0xFFF&logimage_x;    

  z = (x_nonzero <<12)|(0xFFF&(x_body<<1));
  z &= 0x1FFF;
  *logimage_z = z;

  return;  
}          
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* logarithmic UNSIGNED adder */                                   
/* nbit_log   :   14-bit      */          
/* nbit_man   :   5-bit      */          
/* --- [NOTE!] ---
   Input/Output width of this component is 13-bit.      */

#include<stdio.h>                                                  
#include<math.h>                                                   
void pg_log_unsigned_add_log14_man5(int logimage_x, int logimage_y, int* logimage_z){
  int signz=0;  /* 1-bit */                                        
  int x1=0;     /* 14-bit */                  
  int y1=0;     /* 14-bit */                  
  int xy=0;     /* 14-bit (x1 - y1) */        
  int yx=0;     /* 14-bit (y1 - x1) */        
  int yx_msb=0; /*  1-bit SIGN of yx */                            
  int x2=0; /* 13-bit output of Left-MUX  */
  int d0=0; /* 13-bit output of Right-MUX */
  int d0_low_part=0;    /* TABLE INPUT */                          
  int d0_high_part=0;   /* MUX Middle INPUT */                     
  int df=0;             /* MUX Middle OUTPUT */                    
  int table_data=0;     /* TABLE OUTPUT */                         
  int logimage_ZperX=0; /* Logimage of (Real)Z/X */                

  /* SIGN EVALUATION                      
          ----------------------------    
          nonz(X) | nonz(Y) -> sign(Z)    
          --------+-------------------    
             0    |   0     ->   0        
             0    |   1     -> sign(Y)    
             1    |   0     -> sign(X)    
             1    |   1     -> sign(X)    
          ----------------------------  */
  {
    int nonzx,nonzy,signx,signy;
    signx = (logimage_x>>13)&0x1;
    signy = (logimage_y>>13)&0x1;
    nonzx = (logimage_x>>12)&0x1;
    nonzy = (logimage_y>>12)&0x1;
    if(      (nonzx==0x0)&&(nonzy==0x0)){ signz = 0x0;   }
    else if((nonzx==0x0)&&(nonzy==0x1)){  signz = signy; }
    else if((nonzx==0x1)&&(nonzy==0x0)){  signz = signx; }
    else{ /*(nonzx==0x1)&&(nonzy==0x1) */ signz = signx; }
  }

  /* RESET FUNCTION */ 
  {
    int nonzx;
    int nonzy;
    nonzx = 0x1&(logimage_x>>12);
    nonzy = 0x1&(logimage_y>>12);
    if(nonzx == 0x0) logimage_x &= 0x0;
    if(nonzy == 0x0) logimage_y &= 0x0;
  }

  x1 = 0x1FFF&logimage_x; /* The MSB(14th-bit) is zero. */
  y1 = 0x1FFF&logimage_y; /* The MSB(14th-bit) is zero. */

  /* SUB (Y-X),(X-Y) */                                            
  yx = 0x3FFF&(y1 - x1);                       
  xy = 0x3FFF&(x1 - y1);                       

  yx_msb = 0x1 & (yx >>13);                 

  /* MUX Left */
  if(yx_msb==0x1){x2=0x1FFF&logimage_x;}else{x2=0x1FFF&logimage_y;}

  /* MUX Right */
  if(yx_msb==0x1){d0=0x1FFF&xy;}else{d0=0x1FFF&yx;}

  /* ===========================
     table input  = 8 bits                   
     table output = 6 bits                  
     =========================== */
  d0_low_part  = 0xFF&d0;      /* 8-bit */
  d0_high_part = 0x1F&(d0>>8); 

  /* MUX Middle */
  if(d0_high_part == 0x0){ df=0x1; }else{ df=0x0; }                

  /* TABLE LOG_ADD */
  {                                                                                     
    int table_adr = 0;                                                                  
    double D = 0.0;                                                                     
    double z_x = 0.0;                                                                   
    table_adr = d0_low_part; /* (logimage X) - (logimage Y) */                          
    D = ((double)table_adr+0.25)/32.000000;                              
    z_x = (log(1.0+pow(2.0,-1.0*D ))/log(2.0));   /* logimage[(Real)Z/X] */             
    z_x *= 32.000000;                                                    
    table_data = (int)(z_x+0.5);                                                        
    table_data &= 0x3F;  /* TABLE OUTPUT : 6-bit */
  }                                                                                     

  /* MUX Last */
  if(df == 0x1){ logimage_ZperX = table_data; }else{ logimage_ZperX = 0;}

  /* ADDER :13-bit width */ 
  {                                                
    int add_out=0;                                 
    add_out = x2 + logimage_ZperX;                 
    add_out &= 0x1FFF;       
                   /* WITH SIGN-BIT (2002/07/26) */
    *logimage_z = (signz<<13) | add_out;
  }                                                

  return;  
}          
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* PIPELINE DELAY */
/* nbit   :   14-bit    */
/* npipe  :   3-stage  */
 
#include<stdio.h>                                
void pg_pdelay_14_np3(int indata, int* outdata){
  *outdata = 0x3FFF&indata;      
  return;                                        
}          
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* nbit   :   14-bit      */
/* ADDSUB :   SUB          */
#include<stdio.h>
void pg_fix_sub_14(int x,int y,int* z){
  unsigned int _x;
  unsigned int _y;
  int _z;
  _x = 0x3FFF&x;
  _y = 0x3FFF&y;
  _z = (int)(_x - _y);
  *z = 0x3FFF&_z;
}
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* nbit_fix   :   14-bit      */          
/* nbit_log   :   14-bit      */          
/* nbit_man   :   5-bit      */          
#include<stdio.h>                                                  
#include<math.h>                                                   
void pg_conv_ftol_fix14_log14_man5(int fixdata, int* logdata){                 
  int fixdata_msb=0;                                               
  int logdata_sign=0;                                              
  int fixdata_body=0;                                              
  int abs=0;                                                       
  int abs_decimal=0;                                               
  int logdata_nonzero=0;                                           
  int penc_out = 0; /* Output of penc */                           
  int table_adr = 0;                                               
  int table_overflow = 0;                                          
  int logdata_mantissa=0;                                          
  int logdata_exponent=0;                                          

  /* SIGN BIT */                                                   
  fixdata_msb = 0x1&(fixdata >>13);         
  logdata_sign = fixdata_msb;                                      

  /* ABSOLUTE */                                                   
  fixdata_body    = 0x1FFF & fixdata;        
  {                                                                
    int inv_fixdata_body=0;                                        
    inv_fixdata_body = 0x1FFF ^ fixdata_body;
    if(fixdata_msb == 0x1){                                        
      abs = 0x1FFF & (inv_fixdata_body + 1); 
    }else{                                                         
      abs = fixdata_body;                                          
    }                                                              
  }                                                                
  abs_decimal = 0xFFF& abs;                 

  /* GENELATE NON-ZERO BIT (ALL BIT OR) */                                 
  if(abs != 0x0){ logdata_nonzero = 0x1; }else{ logdata_nonzero=0x0; }     

  { /* PRIORITY ENCODER */                                         
    int i;                                                         
    int count=0;                                                   
    for(i=31;i >=0;i--){                                           
        int buf;                                                   
        buf = 0x1 & (abs >>i);                                     
        if(buf == 0x1){ count = i; break;}                         
        count = i;                                                 
    }                                                              
    penc_out=count;                                                
  }                                                                
  penc_out = 0xF & penc_out; /* 4-bit */
  
  /* SHIFTER */                                                                      
  {                                                                                  
    int seed=0;                                                                      
    if(penc_out>=7){                                         
      seed = abs_decimal;                                                            
      table_adr = 0x7F & (seed>>(penc_out-7));
    }else{                                                                           
      seed = abs_decimal << 7;                               
      table_adr = 0x7F & (seed>>penc_out);                         
    }                                                                                
  }                                                                                  
  
  /* TABLE */                                                                        
  /* TABLE INPUT WIDTH  = 7-bit */                           
  /* TABLE OUTPUT WIDTH = 5-bit */                             
  {                                                                                  
    int adr=0;                                                                       
    double adr_double=0.0;                                                           
    double data_double=0.0;                                                          
    int data;                                                                        
    adr = 0x7F & table_adr;                                  
    adr_double =   ( ((double)adr) + 0.5 )/128.000000;   
    data_double = 32.000000*(log(1.0 + adr_double))/log(2.0) + 0.5;
    data = (int)data_double;                                                         
    /* CHECK OVERFLOW */                                                             
    if((0x1&(data >>5))==0x1){                                   
      data = 0;                                                                      
      table_overflow = 1;   /* overflow flag */                                      
    }else{                                                                           
      table_overflow = 0;                                                            
    }                                                                                
    logdata_mantissa = 0x1F & data;                            
  }                                                                                  
  
  /* ADDER (GENERATE EXPONENT PART) */                                               
  logdata_exponent = 0xF & (penc_out + table_overflow);  
  
  *logdata = logdata_sign << 13| logdata_nonzero << 12| logdata_exponent << 5| logdata_mantissa ;
  
  return;                                                          
}                                                                  
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* nbit   :   14-bit      */                  
/* MULDIV :   MUL          */                  
#include<stdio.h>                                                  
void pg_log_mul_14(int x,int y,int* z){                        
  int _signbit_x=0;                                                
  int _signbit_y=0;                                                
  int _signbit_z=0;                                                
  int _nonzbit_x=0;                                                
  int _nonzbit_y=0;                                                
  int _nonzbit_z=0;                                                
  int _x=0;                                                        
  int _y=0;                                                        
  int _z=0;                                                        
  _signbit_x = 0x1&(x >> 13);               
  _signbit_y = 0x1&(y >> 13);               
  _signbit_z = _signbit_x ^ _signbit_y;                            
  _nonzbit_x = 0x1&(x >> 12);               
  _nonzbit_y = 0x1&(y >> 12);               
  _nonzbit_z = _nonzbit_x & _nonzbit_y;                            
  _x = 0xFFF&x;                              
  _y = 0xFFF&y;                              
  _z = _x + _y;                                                  
  _z = 0xFFF&_z;                           
  *z = _signbit_z << 13 | _nonzbit_z << 12 | _z;                                                           
  *z = 0x3FFF&(*z);                              
  return;                                                          
}                                                                  
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* SIGNED logarithmic adder */
/* nbit_log   :   14-bit      */
/* nbit_man   :   5-bit      */
/* input width of table(+)   :   8-bit    */
/* output width of table(+)  :   5-bit    */
/* input width of table(-)   :   8-bit    */
/* output width of table(-)  :   8-bit    */
/* Estimation of the table size: 3328 bits */
/*
   logimage[13] (MSB): Signed Frag
   logimage[12]      : Non-Zero Frag
   logimage[11 downto 5] : log part of exponent
   logimage[4 downto 0]  : log part of mantissa
*/

#include<stdio.h>
#include<math.h>
void pg_log_add_log14_man5(int logimage_x, int logimage_y, int* logimage_z){
  int signz=0;
  int zlogpart=0;
  int signx=0;     /* signed-frag of logimage_x */
  int signy=0;     /* signed-frag of logimage_y */
  int x=0;         /* logpart of logimage_x */
  int y=0;         /* logpart of logimage_y */
  int xy=0;     /* 13-bit (x - y) */
  int yx=0;     /* 13-bit (y - x) */
  int signxy=0; /*  1-bit SIGN of xy */
  int d=0;      /*  X-Y(X>=Y) or Y-X(X<Y) */
  int add_operand=0;
  int func_plus=0;   /* output of the function plus part */
  int func_minus=0;  /* output of the function plus part */


  signx = (logimage_x>>13)&1;
  signy = (logimage_y>>13)&1;
  x= 0x1FFF&logimage_x;
  y= 0x1FFF&logimage_y;

  /* X RESET FUNCTION */
  {
    int _nonzero = 0x1&(x>>12);
    if(_nonzero == 0x0){ x = 0;} /* RESET */
  }
  /* Y RESET FUNCTION */
  {
    int _nonzero = 0x1&(y>>12);
    if(_nonzero == 0x0){ y = 0;} /* RESET */
  }
  /* SUBTRACTORS */
  /* X - Y */
  xy = x + (0x3FFF&((0x3FFF^y)+1));  xy &= 0x3FFF; /* 14-bit arithmetic (the MSB of each operands is 0.)*/
  /* Y - X */
  yx = y + (0x1FFF&((0x1FFF^x)+1));  yx &= 0x1FFF; /* 13-bit arithmetic */

  signxy = (xy>>13)&0x1;
  xy &= 0x1FFF; /* sharpen the MSB-bit */

  /* MULTIPLEXOR (1) */
  if(signxy == 0){
    d = xy;
  }else{
    d = yx;
  }

  /* MULTIPLEXOR (2) */
  if(signxy == 0){
    add_operand= x;
  }else{
    add_operand = y;
  }

  /* PLUS FUNCTION PART */
  {
    int d_low_part=0;    /* TABLE INPUT : d[7 downto 0] */
    int d_high_part=0;   /* MUX Middle INPUT : d[12 downto 8] */
    int is_zero=0;       /* ALL OR */
    int one=0;           /* MSB of this function's output */
    int table_data = 0;  /* 5-bit (only mantissa) */
    int logdiff = 0;     /* 6-bit (one-frag + table_data(mantissa)) */
    d_low_part = 0xFF&d;
    d_high_part = 0x1F&(d>>8);
    /* ALL OR */
    if(d_high_part == 0x0){is_zero = 0x0;}else{is_zero=0x1;}
    /* GEN MSB-BIT (ALL OR -> NOT) */
    if(d_low_part == 0x0){one = 0x1;}else{one=0x0;}
    /* TABLE LOG_ADD */
    {
      int table_adr = 0;
      double D = 0.0;
      double z_x = 0.0;
      table_adr = d_low_part; /* (logimage X) - (logimage Y) */
      D = ((double)table_adr+0.25)/32.000000;
      z_x = (log(1.0+pow(2.0,-1.0*D))/log(2.0)); /* logimage[(Real)Z/X] */
      z_x *= 32.000000;
      z_x += 0.5;
      table_data = (int)(z_x);
      table_data &= 0x1F;
    }
    logdiff = one<<5|table_data;
    /* MULTIPLEXOR */
    if(is_zero == 0x0){ func_plus=logdiff; }else{ func_plus=0x0;}
  }

  /* MINUS FUNCTION PART */
  {
    int d_low_part=0;    /* TABLE INPUT : d[7 downto 0] */
    int d_high_part=0;   /* MUX Middle INPUT : d[12 downto 8] */
    int is_zero=0;       /* ALL OR */
    int table_data = 0;  /* 8-bit  */
    int minusval = 0;    /* 8-bit  */
    int func_minus_high_part = 0;  /* 5-bit  */
    d_low_part = 0xFF&d;
    d_high_part = 0x1F&(d>>8);
    /* ALL OR */
    if(d_high_part == 0x0){is_zero = 0x0;}else{is_zero=0x1;}
    /* TABLE LOG_SUB */
    {
      int table_adr = 0;
      double D = 0.0;
      double z_x = 0.0;
      table_adr = d_low_part; /* (logimage X) - (logimage Y) */
      D = ((double)table_adr+0.25)/32.000000;
      z_x = (log(1.0-pow(2.0,-1.0*D))/log(2.0)); /* logimage[(Real)Z/X] */
      z_x *= 32.000000;
      z_x *= -1.0;  /*-- bug fixed 2002/08/20 --*/
      z_x += 0.5;   /*-- bug fixed 2002/08/20 --*/
      table_data = (int)(z_x);
      if(table_adr==0x0){table_data=0x0;} /* ATTENTION: Input=0x0, Output=don't care. */
      table_data &= 0xFF;
    }
    /* MULTIPLEXOR */
    if(is_zero == 0x1){ table_data=0x0; }
    /* 2's completition */
    table_data = 0xFF&(0xFF^table_data);
    minusval = 0xFF&(table_data + 1);
    /* MULTIPLEXOR */
    if(minusval == 0x0){
      func_minus_high_part=0x0;
    }else{
      func_minus_high_part=0x1F;
    }
    func_minus = (func_minus_high_part<<8)|minusval;
  }

  /* LAST ADDITION */ 
  {
    int inc=0;
    int addout=0;
    /* MULTIPLEXOR */
    if(signx == signy){
      inc = func_plus;
    }else{
      inc = func_minus;
    }
    /* ADDER */
    addout = add_operand + inc;
    addout &= 0x1FFF;
    zlogpart = addout;
  }

  /* SIGN Z */ 
  if(signx == signy){
    signz = signx;
  }else{
    signz = signx ^ signxy;
  }

  /* NON-ZERO EVALUATION WHEN (X<>Y AND |X|=|Y| -> Z=ZERO */ 
  {
    int nonzero_mask;
    int nonzero_z;
    if((signx != signy)&&(d==0x0)){nonzero_mask=0x0;}else{nonzero_mask=0x1;}
    nonzero_z =  (zlogpart >>12)&nonzero_mask;
    *logimage_z = (signz<<13)|(nonzero_z<<12)|(0xFFF&zlogpart);
  }

  return;
}
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* PIPELINE DELAY */
/* nbit   :   14-bit    */
/* npipe  :   11-stage  */
 
#include<stdio.h>                                
void pg_pdelay_14_np11(int indata, int* outdata){
  *outdata = 0x3FFF&indata;      
  return;                                        
}          
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* PIPELINE DELAY */
/* nbit   :   14-bit    */
/* npipe  :   1-stage  */
 
#include<stdio.h>                                
void pg_pdelay_14_np1(int indata, int* outdata){
  *outdata = 0x3FFF&indata;      
  return;                                        
}          
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* nbit   :   14-bit      */                  
/* MULDIV :   DIV          */                  
#include<stdio.h>                                                  
void pg_log_div_14(int x,int y,int* z){                        
  int _signbit_x=0;                                                
  int _signbit_y=0;                                                
  int _signbit_z=0;                                                
  int _nonzbit_x=0;                                                
  int _nonzbit_y=0;                                                
  int _nonzbit_z=0;                                                
  int _x=0;                                                        
  int _y=0;                                                        
  int _z=0;                                                        
  _signbit_x = 0x1&(x >> 13);               
  _signbit_y = 0x1&(y >> 13);               
  _signbit_z = _signbit_x ^ _signbit_y;                            
  _nonzbit_x = 0x1&(x >> 12);               
  _nonzbit_y = 0x1&(y >> 12);               
  _nonzbit_z = _nonzbit_x & _nonzbit_y;                            
  _x = 0xFFF&x;                              
  _y = 0xFFF&y;                              
  _z = _x - _y;                                                  
  _z = 0xFFF&_z;                           
  *z = _signbit_z << 13 | _nonzbit_z << 12 | _z;                                                           
  *z = 0x3FFF&(*z);                              
  return;                                                          
}                                                                  
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* nbit   :   14-bit      */                  
/* MULDIV :   SDIV          */                  
#include<stdio.h>                                                  
void pg_log_sdiv_14(int x,int y,int* z){                        
  int _signbit_x=0;                                                
  int _signbit_y=0;                                                
  int _signbit_z=0;                                                
  int _nonzbit_x=0;                                                
  int _nonzbit_y=0;                                                
  int _nonzbit_z=0;                                                
  int _x=0;                                                        
  int _y=0;                                                        
  int _z=0;                                                        
  _signbit_x = 0x1&(x >> 13);               
  _signbit_y = 0x1&(y >> 13);               
  _signbit_z = _signbit_x ^ _signbit_y;                            
  _nonzbit_x = 0x1&(x >> 12);               
  _nonzbit_y = 0x1&(y >> 12);               
  _nonzbit_z = _nonzbit_x & _nonzbit_y;                            
  _x = 0xFFF&x;                              
  _y = 0xFFF&y;                              
  _z = _x - _y;                                                  
  if(_y>_x) _z = 0;                                              
  _z = 0xFFF&_z;                           
  *z = _signbit_z << 13 | _nonzbit_z << 12 | _z;                                                           
  *z = 0x3FFF&(*z);                              
  return;                                                          
}                                                                  
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* nbit_log   :   14-bit      */          
/* nbit_man   :   5-bit      */          
/* nbit_fix   :   57-bit      */          
#include<stdio.h>                                                  
#include<math.h>                                                   
void pg_conv_ltof_log14_man5_fix57(int logdata, long long int* fixdata){       
  int logdata_sign=0;                                              
  int logdata_nonzero=0;                                           
  int logdata_exponent=0;                                          
  int logdata_mantissa=0;                                          
  int fixdata_sign=0;                                              
  unsigned long long int fixdata_absolute=0;                       
  int table_adr=0;                                                 
  int table_data=0;                                                
  int shift_indata=0;                                              
  int shift_control=0;                                             

  /* VECTOR PREPARATION */                                         
  logdata_sign=0x1&(logdata>>13);     
  logdata_nonzero=0x1&(logdata>>12);     
  logdata_exponent=0x7F&(logdata>>5);       
  logdata_mantissa=0x1F&logdata;            

  /* SIGN BIT */                                                   
  fixdata_sign=logdata_sign;                                       

  /* TABLE */                                                      
  table_adr = logdata_mantissa;                                    
  {                                                                
    double x     = 0.0;                                            
    double y     = 0.0;                                            
    double depth = 32.000000;                     
    x = pow(2.0,((double)table_adr)/depth);                        
    y = (32.000000*(x-1.0)) +0.5; 
    table_data = (int)y;                                           
    table_data &= 0x1F;                    
  }                                                                

  /* MULTIPLEXOR */                                                
  {                                                                
    int muxout=0;                                                  
    if(logdata_nonzero == 0x1){                                    
      muxout = 0x1 << 5 | table_data;
    }else{                                                         
      muxout = 0x0;                                                
    }                                                              
    shift_indata = muxout;                                         
  }                                                                

  /* SHIFTER */                                                    
  shift_control = logdata_exponent;                                
  {                                                                
    unsigned long long int shift_out=0;                            
    unsigned long long int seed=0;                                 
    if(shift_control < 8*sizeof(long long int)){
      seed = ((unsigned long long int)shift_indata) << shift_control;
    }else{
      seed = 0x0LL;
    }
    shift_out = seed >> 5;   
    fixdata_absolute = 0x00FFFFFFFFFFFFFFULL & shift_out;   
  }                                                                

  *fixdata = (long long int)fixdata_sign << 56 | fixdata_absolute;

  return;                                                          
}                                                                  
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* Fixed-Point Accumulate Registor*/                          
/* nbit_fx(input)   :   57-bit      */
/* nbit_sx(register):   64-bit      */
/* --- [NOTE!] ---
   The format of input data is not the 2's complement one.
   MSB means a sign flag, and the other part means abusolute(not<0) integer. */

#include<stdio.h>                                                  
#include<math.h>                                                   
void pg_fix_accum_f57_s64(long long int fdata, long long int* sdata){ 
  long long int fx=0;     /* 57-bit */         
  long long int sx=0;     /* 64-bit */         
  long long int fx_sign=0;     /* 1-bit : sign flag of fdata */     
  long long int fx_abs=0;      /* 56-bit : absolute part of fdata */
  fx= 0x01FFFFFFFFFFFFFFULL&fdata;                             
  sx= 0xFFFFFFFFFFFFFFFFULL&(*sdata);                          
  fx_sign = 0x1&(fdata >>56);               
  fx_abs  = 0x00FFFFFFFFFFFFFFULL&fdata;                    
  if(fx_sign == 0x0){                                              
    sx = sx + fx_abs;                                              
  }else{                                                           
    sx = sx - fx_abs;                                              
  }                                                                

  *sdata = 0xFFFFFFFFFFFFFFFFULL&sx;
  return;  
}          
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* PIPELINE DELAY */
/* nbit   :   14-bit    */
/* npipe  :   5-stage  */
 
#include<stdio.h>                                
void pg_pdelay_14_np5(int indata, int* outdata){
  *outdata = 0x3FFF&indata;      
  return;                                        
}          
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* PIPELINE DELAY */
/* nbit   :   14-bit    */
/* npipe  :   13-stage  */
 
#include<stdio.h>                                
void pg_pdelay_14_np13(int indata, int* outdata){
  *outdata = 0x3FFF&indata;      
  return;                                        
}          
/* Generated by PGPG module generateor       */
/* Copyright(c) 2001-2004 by Tsuyoshi Hamada */
/* PIPELINE DELAY */
/* nbit   :   14-bit    */
/* npipe  :   2-stage  */
 
#include<stdio.h>                                
void pg_pdelay_14_np2(int indata, int* outdata){
  *outdata = 0x3FFF&indata;      
  return;                                        
}          
